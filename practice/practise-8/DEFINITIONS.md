
# Список терминов семинара
###### Нужно написать определения с примером из жизни или кода
- Что такое ddd? зачем нужно так разделяется?

Разделение приложения на слои работающие по одному принципу

Обычно деляет на 4 слоя:
1) Доменный слой (бизнес логика)
2) Слой приложения (только вызовы, никакой логики)
3) Инфраструктурный слой (все, что связано с техникой)
4) Презентационный слой (точка входа в систему, связь с внешним миром)
   Необходимо для изоляции частей проекта друг от друга, чтобы внесение изменений в одном месте не несло изменения в другом
   Более того, в таком случае маштабирование и расширение происходит гораздо проще
- Что такое event storming?

Процесс визуализации и построения бизнесс-домена всей командой разработчиков

Обычно используют доменные события (то, что уже произошло), команды, агрегаты(места, где живет логика) и пользователей
- json что за формат, зачем нужен?

Формат хранения объектов при помощи синтакса JavaScript
- MARKDOWN что за формат, зачем нужен?

Формат хранения текста, который удобно изменять и конвертировать
- XML что за формат, зачем нужен?

Формат хранения объектов, похожий на формат страниц в браузере
- CSV что за формат, зачем нужен?

Формат хранения, похожий на таблицу

Сравнение форматов хранения

| Параметр                         | JSON                          | XML                          | CSV                          | Markdown                    |
|----------------------------------|-----------------------------------|----------------------------------|----------------------------------|---------------------------------|
| Читаемость человеком             | Высокая                           | Средняя                          | Высокая                          | Высокая                         |
| Объём данных (вес файла)        | Меньше, чем XML                   | Больше, из-за тегов              | Наименьший                       | Очень маленький (текст)         |
| Вложенность/структура           | Есть (объекты, массивы)           | Есть (вложенные теги)           | Нет (плоская структура)         | Нет (плоская структура)         |
| Типизация данных                | Частичная (по значениям)          | Нет, но можно через XSD          | Всё строки                      | Нет (текстовый формат)          |
| Валидация схемы                 | Ограничена (JSON Schema)          | Есть (XSD)                       | Нет                             | Нет                             |
| Расширяемость                   | Хорошая                           | Отличная                         | Ограниченная                    | Хорошая (можно добавлять новые элементы) |
| Сложность парсинга              | Средняя (удобная в работе)        | Высокая (больше кода)            | Низкая                           | Очень низкая (практически нет парсинга) |
| Поддержка вложенных структур    | Да                                | Да                               | Нет                             | Нет                             |
| Подходит для табличных данных   | Можно, но не идеально             | Можно, но тяжело                 | Идеально                        | Ограниченно (можно с помощью таблиц, но не так удобно) |
| Примеры использования           | REST API, frontend, NoSQL         | SOAP, Android, документы         | Excel, отчёты, интеграции       | Документация, блоги, README, вики-страницы |

Использование:
1) JSON — для обмена структурированными данными через API, особенно в веб-разработке.
2) XML — если нужна сложная структура, валидация, документы или старые системы (например, SOAP, 1С).
3) CSV — когда нужно просто и быстро передать табличные данные, особенно в интеграциях, отчётах, Excel.
4) Markdown — для написания документации, блогов, README файлов, вики-страниц и других текстовых файлов с форматированием.

- REST

Архитектурный стиль создания веб-сервисов

Основные принципы
1) Клиент-сервер - есть только два компонента в структуре, взаимодейтсвие между которыми через http
2) Без состояния - каждый запрос самодостаточен, система не хранит данные о предыдущих запросах
3) Кэшируемость - для повышения производительности
4) Единообразие интерфейса - все выполняем с помощью стандартных методов
5) Системная модель слоёв - могут встречаться промежуточные серверы, до пересылки на основной
- SOAP

Протокол обмена сообщениями

Структура сообщения

1) Заголовок
2) Тело
3) Ошибка

Пример

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:web="http://www.example.com/webservice">
   <soapenv:Header/>
   <soapenv:Body>
      <web:getUserDetails>
         <userId>123</userId>
      </web:getUserDetails>
   </soapenv:Body>
</soapenv:Envelope>

```

- +1 уникальный факт связанный с темами выше или семинаром

При десереализации в json из Java в случае наследования(полиморфизма) есть 2 пути
1) Мы знаем наследников

```Java
@JsonTypeInfo(
  use = JsonTypeInfo.Id.NAME,
  include = JsonTypeInfo.As.EXTERNAL_PROPERTY,
  property = "type"
)
@JsonSubTypes({
  @JsonSubTypes.Type(value = Dog.class, name = "dog"),
  @JsonSubTypes.Type(value = Cat.class, name = "cat")
})
public class Animal{}
```
2) Мы не знаем наследников
```Java
@JsonTypeInfo(
    use = JsonTypeInfo.Id.CLASS, 
    include = JsonTypeInfo.As.PROPERTY, 
    property = "@class" // тут он самостоятельно подставит класс
)
public class Animal{}

public class Dog extends Animal{}
```
`